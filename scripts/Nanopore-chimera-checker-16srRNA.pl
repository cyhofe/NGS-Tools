#!/usr/bin/env perl

###############################################################################
# Nanopore-16S-chimera-check-yacrd.pl
#
# Author: Cyrill Hofer
# Created: 22.04.2024
# Updated: 18.02.2026
#
# DESCRIPTION
# -----------------------------------------------------------------------------
# This script generates (and optionally executes) a workflow to identify and
# filter potential chimeric Nanopore 16S amplicon reads using yacrd.
#
# IMPORTANT NOTE (FIX vs ORIGINAL TEXT)
# -----------------------------------------------------------------------------
# Your script description says “map the reads against itself”, but the original
# minimap2 command mapped reads to a provided reference.
#
# In practice, yacrd needs an overlap file (PAF/SAM) generated by mapping reads
# against themselves (all-vs-all overlaps). Therefore, this cleaned version:
#
#   - maps READS vs READS: minimap2 reads.fq.gz reads.fq.gz > overlaps.paf
#
# You still can provide --ref, but it is now OPTIONAL and only used if you
# explicitly enable it (see --mode).
#
# WORKFLOW STEPS
# -----------------------------------------------------------------------------
#  1) Compute overlaps (PAF) using minimap2 in all-vs-all mode
#  2) Run yacrd to filter reads based on overlap evidence
#  3) Run NanoStat on filtered reads
#  4) Cleanup intermediates
#
# REPRODUCIBILITY / HPC DESIGN
# -----------------------------------------------------------------------------
# Writes a self-contained bash script:
#   <prefix>.ChimeraChecker.sh
#
# By default it ONLY generates the bash script. Use --run to execute immediately
# or submit the bash script to your HPC scheduler.
#
# DEPENDENCIES
# -----------------------------------------------------------------------------
# Required executables (must be in PATH OR provided via *_dir options):
#  - minimap2
#  - yacrd
#  - NanoStat (NanoPack)
#
# Optional directory overrides:
#  --minimap2_dir DIR   Directory containing minimap2
#  --yacrd_dir DIR      Directory containing yacrd
#  --nanostat_dir DIR   Directory containing NanoStat
#
###############################################################################

use strict;
use warnings;

use Getopt::Long qw(GetOptions);
use File::Path qw(make_path);
use Cwd qw(getcwd);
use POSIX qw(strftime);

my $USAGE = <<"USAGE";

Usage:
  $0 -f reads.fq.gz -p PREFIX -o OUTPUT_DIR [options]

Required:
  -f, --file FILE         Nanopore reads (FASTQ/FASTQ.GZ)
  -p, --prefix PREFIX     Prefix for output files
  -o, --output DIR        Output directory (will be created)

Options:
  --ncpu INT              Threads (default: 40)

  --minimap2_dir DIR      Directory containing minimap2 (optional; else PATH)
  --yacrd_dir DIR         Directory containing yacrd (optional; else PATH)
  --nanostat_dir DIR      Directory containing NanoStat (optional; else PATH)

  --mode STR              Overlap mode: self|ref (default: self)
                          self = map reads against themselves (recommended for yacrd)
                          ref  = map reads against a reference (requires --ref)

  --ref FILE              Reference FASTA/FASTQ for --mode ref (optional otherwise)

  --run                   Execute generated workflow immediately
  --force                 Allow existing output folder (may overwrite files)
  -h, --help              Show help

Examples:
  # Recommended (self overlaps):
  $0 -f reads.fq.gz -p sample16S -o sample16S.yacrd --run

  # If you really want ref mapping (less typical for yacrd):
  $0 -f reads.fq.gz -p sample16S -o sample16S.yacrd --mode ref --ref silva.fasta --run

USAGE

# ----------------------------
# Args + defaults
# ----------------------------
my ($file,$prefix,$output,$help);
my ($NCPU);
my ($minimap2_dir,$yacrd_dir,$nanostat_dir);
my ($mode,$reference);
my ($run,$force);

$NCPU = 40;
$mode = "self";

GetOptions(
  "f|file=s"        => \$file,
  "p|prefix=s"      => \$prefix,
  "o|output=s"      => \$output,
  "ncpu=i"          => \$NCPU,

  "minimap2_dir=s"  => \$minimap2_dir,
  "yacrd_dir=s"     => \$yacrd_dir,
  "nanostat_dir=s"  => \$nanostat_dir,

  "mode=s"          => \$mode,
  "ref|reference=s" => \$reference,

  "run!"            => \$run,
  "force!"          => \$force,
  "h|help"          => \$help,
) or die $USAGE;

die $USAGE if $help;

die "ERROR: Missing -f/--file\n$USAGE"   unless $file;
die "ERROR: Missing -p/--prefix\n$USAGE" unless $prefix;
die "ERROR: Missing -o/--output\n$USAGE" unless $output;

die "ERROR: --mode must be 'self' or 'ref'\n" unless $mode eq "self" || $mode eq "ref";
if ($mode eq "ref") {
  die "ERROR: --mode ref requires --ref/--reference\n$USAGE" unless $reference;
}

# ----------------------------
# Helpers
# ----------------------------
sub resolve_exec {
  my ($dir, $exe, $display_name) = @_;
  $display_name ||= $exe;

  if (defined $dir && $dir ne "") {
    $dir =~ s{/$}{};
    my $path = "$dir/$exe";
    die "ERROR: Cannot find executable for $display_name at: $path\n" unless -x $path;
    return $path;
  }

  my $which = `command -v $exe 2>/dev/null`;
  chomp $which;
  die "ERROR: '$exe' ($display_name) not found in PATH. Provide *_dir or load module/conda env.\n"
    unless $which;

  return $exe;
}

sub shell_quote {
  my ($s) = @_;
  $s =~ s/'/'"'"'/g;
  return "'$s'";
}

# ----------------------------
# Resolve tools
# ----------------------------
my $MINIMAP2 = resolve_exec($minimap2_dir, "minimap2", "minimap2");
my $YACRD    = resolve_exec($yacrd_dir,    "yacrd",    "yacrd");
my $NANOSTAT = resolve_exec($nanostat_dir, "NanoStat", "nanostat");

# ----------------------------
# Output dir
# ----------------------------
if (-d $output && !$force) {
  die "ERROR: Output folder '$output' already exists. Use --force to proceed.\n";
}
make_path($output) unless -d $output;

# ----------------------------
# Files
# ----------------------------
my $scriptfile = "$prefix.ChimeraChecker.sh";

my $paf        = "$output/$prefix.overlaps.paf";
my $yacrd_out  = "$output/$prefix.yacrd";
my $filtered   = "$output/$prefix.cc.fq.gz";
my $nanostat_o = "$output/$prefix.cc.NanoStat.txt";

# ----------------------------
# Generate workflow script
# ----------------------------
open(my $OUT, ">", $scriptfile) or die "ERROR: Cannot write '$scriptfile': $!\n";

my $date = strftime("%Y-%m-%d %H:%M:%S", localtime);
my $cwd  = getcwd();

print $OUT <<"SCRIPT";
#!/usr/bin/env bash
set -euo pipefail

# Generated by: $0
# Generated on: $date
# Working directory: $cwd
# Input: $file
# Prefix: $prefix
# Output: $output
# Mode: $mode
SCRIPT

if ($mode eq "self") {
print $OUT <<"SCRIPT";

echo "---------------------- [1/3] Overlap mapping (minimap2, self vs self)"
# yacrd expects an overlap file; self-overlaps are the common use case.
${\shell_quote($MINIMAP2)} -x map-ont -t $NCPU ${\shell_quote($file)} ${\shell_quote($file)} > ${\shell_quote($paf)}
echo "---------------------- DONE minimap2 overlaps"
SCRIPT
} else {
print $OUT <<"SCRIPT";

echo "---------------------- [1/3] Mapping to reference (minimap2, ref mode)"
${\shell_quote($MINIMAP2)} -x map-ont -t $NCPU ${\shell_quote($reference)} ${\shell_quote($file)} > ${\shell_quote($paf)}
echo "---------------------- DONE minimap2 ref mapping"
SCRIPT
}

print $OUT <<"SCRIPT";

echo "---------------------- [2/3] Filter chimeric reads (yacrd)"
# yacrd needs the overlap PAF and the original reads.
# It writes a report-like file ($yacrd_out) and outputs filtered reads.
${\shell_quote($YACRD)} --input ${\shell_quote($paf)} --output ${\shell_quote($yacrd_out)} filter \\
  --input ${\shell_quote($file)} --output ${\shell_quote($filtered)}
echo "---------------------- DONE yacrd filtering"

echo "---------------------- [3/3] NanoStat on filtered reads"
${\shell_quote($NANOSTAT)} --fastq ${\shell_quote($filtered)} -t $NCPU > ${\shell_quote($nanostat_o)}
echo "---------------------- DONE NanoStat"

echo "---------------------- Cleanup"
rm -f ${\shell_quote($paf)}
# Keep yacrd report by default (useful diagnostics). If you want to delete it, uncomment:
# rm -f ${\shell_quote($yacrd_out)}
echo "Final output: $filtered"
echo "Yacrd report: $yacrd_out"
echo "---------------------- DONE"
SCRIPT

close $OUT;
chmod 0755, $scriptfile;

print "Generated workflow script: $scriptfile\n";
print "Output folder: $output\n";
print "Filtered output will be: $filtered\n";

# ----------------------------
# Optional execution
# ----------------------------
if ($run) {
  print "Executing workflow (bash $scriptfile)...\n";
  system("bash", $scriptfile) == 0 or die "ERROR: Workflow execution failed.\n";
} else {
  print "Not executed (default). Run with: bash $scriptfile\n";
  print "Or re-run this generator with --run\n";
}

exit 0;

__END__
